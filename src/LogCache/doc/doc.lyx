#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass scrartcl
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language swedish
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle fancy

\layout Title
\added_space_top vfill \added_space_bottom vfill 
Log Caching in TortoiseSVN
\layout Date

Date 2006-06-27
\layout Author

Stefan Fuhrmann (
\emph on 
stefan.fuhrmann@etas.de
\emph default 
)
\layout Abstract

This document describes the details of the TortoiseSVN logbook cache implementat
ion as well as its the design rationales.
\layout Section

Use Cases and User Requirements
\layout Standard

Subversion revision logs basically contain all repository information except
 the actual file and property contents
\begin_inset Foot
collapsed false

\layout Standard

In real life, though, logs are only fetched for a certain sub-set of the
 repository.
\end_inset 

 .
 Hence, many non-modifying operations except content diffs and full-text
 search can be performed solely on that information.
\layout Standard

The downside of this is the sheer size of that information: A few hundred
 megabytes for a large repository's log information may be manageable on
 a decent developer workstation.
 It will be far less convenient on a rather modest notebook.
\layout Standard

While not adhering to a strict (and boring) use-case description style,
 the following sections try to cover as many aspects of the log cache usage.
 They are neither intended to be orthogonal nor complete, though.
\layout Subsection


\begin_inset LatexCommand \label{UC:ShowLatestRevisions}

\end_inset 

Show Latest Revisions
\layout Standard

Maybe, this is the most common usage of logs: display the list of recent
 changes for a given item.
 The user's focus is on changes close to and including HEAD.
 Therefore, the cache will be of some assistance reducing the range of revisions
 to fetch but the client / server communication latency will limit the response
 time.
 
\layout Standard

It may be acceptable to many users not to fetch the delta to HEAD, if the
 cached information is recent enough.
 An option is needed to specify the maximum interval between log cache updates
 with the default being 1 hour.
 F5 should fetch the delta and update the display in any case
\begin_inset Foot
collapsed false

\layout Standard

Please note, this does apply to all log-based features including like statistics
 and revision graphs.
\end_inset 

.
\layout Standard

Another implication of this use case are small but frequent additions to
 the cache log.
 While the user expects other, large log operations to take a noticeable
 amount of time, he / she will assume that 
\begin_inset Quotes sld
\end_inset 

show latest
\begin_inset Quotes srd
\end_inset 

 requests and updates could be done in a second or even less.
\layout Standard

Of course, the caching mechanism should be able to hold the logs multiple
 repositories simultaneously.
 This is necessary to cover even a single working copy containing 
\family typewriter 
svn:externals
\family default 
 referring to other repositories.
\layout Subsection


\begin_inset LatexCommand \label{UC:DigThroughHistory}

\end_inset 

Dig Through History
\layout Standard

In contrast to UC 
\begin_inset LatexCommand \ref{UC:ShowLatestRevisions}

\end_inset 

, the user digs deeper into the log history.
 He / she may want to find the revision a certain branch was created at,
 for instance.
 Or when he made a certain change.
 So, while the previous use case is mainly about a quick information update,
 this one is about searching.
 Efficient filtering is important: If fetching 
\emph on 
all
\emph default 
 the log information is fast, filtering the same should not be major contributor
 to runtime.
\layout Standard

Full-text searches in comment, author and / or changed paths are helpful
 and should be efficient as well.
\layout Standard

In all those cases, the log that is searched spans - often sparsely - over
 many revisions.
 Also, the quest may be started at some arbitrary revision far off HEAD.
\layout Subsection

Statistics
\layout Standard

Statistics are a great tool for identifying trends
\begin_inset Foot
collapsed false

\layout Standard

Example: Does the average number of file changes in a commit increase over
 time? If so, how does the distribution look like, i.e.
 is it only the upper 1% (big merges) that is growing?
\end_inset 

 and verifying assumptions
\begin_inset Foot
collapsed false

\layout Standard

For instance: Am I the one that contributes most to this tool or feature?
\end_inset 

 that are the basis of your source code management strategies.
 Client-side log analysis is very important to those users that don't have
 the rights to add such analysis on the server side.
 Lowering the server load is a positive side-effect.
\layout Standard

There is a lot of information in the log data that makes data mining worthwhile.
 Even a very sophisticated statistics engine will not cover all user needs.
 Because of that, the user should be able to write his / her own data query.
 A public low-level API to iterate over and navigate through all data will
 be sufficient implement any query strategy.
\layout Standard

On top of that, another API layer shall provide grouping, sorting and filtering.
 That's what statistics in TortoiseSVN use today.
 
\layout Subsection

Interactive Revision Graphs
\layout Standard

Up to and including versions 1.4.x of TortoiseSVN, building the revision graph
 is done in two phases both taking a considerable amount of time and consuming
 a lot of memory: Fetching the log data first and building the graph afterwards.
 
\layout Standard

With log caching in place, phase one will be virtually eliminated.
 Hence, the same rationale as in UC 
\begin_inset LatexCommand \ref{UC:DigThroughHistory}

\end_inset 

 applies: the second phase should be sped up.
 The log caching mechanism can be expected to have an efficient representation
 of just the information needed to draw a certain part of the graph.
 Therefore, phase one could be virtually eliminated while phase two will
 be implemented using an efficient query interface on the log cache.
\layout Standard

Once that is done, the user may start drawing the graph at any point in
 the repository space-time and explore it interactively.
\layout Subsection


\begin_inset LatexCommand \label{UC:ReduceRequiredBandwith}

\end_inset 

Reduce Delays and Required Bandwidth 
\layout Standard

Log caching is surely about minimizing user experienced delays.
 Those stem from two main sources: latency of the repository server and
 network round-trips for one and secondly simple networking bandwidth or
 repository server throughput limitations.
 
\layout Standard

Reductions in latency are hard to achieve: Minor optimizations to the server
 query may be possible using several heuristics
\begin_inset Foot
collapsed false

\layout Standard

For instance: get HEAD revision and be done if it did not change.
\end_inset 

.
 The most promising strategy is hiding the latency.
 In that case, the user would see the cached log information first until
 the server response is finally available.
 Please note, that such behavior may be confusing to the unsuspicious user
 because the log delta fetched from the server may contain the deletion
 of the selected item and an addition of the same.
 Hence, only part of that delta is shown in the final display.
\layout Standard

Some people's connection to their repository server may not be exactly 
\begin_inset Quotes srd
\end_inset 

snappy
\begin_inset Quotes srd
\end_inset 


\begin_inset Foot
collapsed false

\layout Standard

Not just modem users but people using connect on demand or having a satellite
 connection will experience huge initial communication setup latencies.
\end_inset 

 making them prefer TortoiseSVN not to connect the server until explicitly
 asked.
 
\layout Standard

Large repositories will have more than a million revisions.
 The most efficient way to fill a log cache for those is by distributing
 
\begin_inset Quotes srd
\end_inset 

log tar balls
\begin_inset Quotes srd
\end_inset 

.
 An easy way to import / export someone's log cache is needed.
 
\layout Standard

Fast repository access is given for workstations accessing the server within
 the LAN.
 If you do not have that LAN connection you are likely to use a notebook
 or other computer with limited RAM, CPU and hard-disk resources.
 Therefore, many log caching users will about a space efficient data representat
ion that is still quickly accessible with reasonable computing power.
\layout Subsection

Offline Functionality
\layout Standard

From time to time and depending on the respective user's settings, TortoiseSVN
 will contact the repository server to update the log information before
 it displays the requested information.
 If the server cannot be reached, the client will be deadlocked until some
 timeout.
 
\layout Standard

To prevent such delays, there shall be an offline mode.
 While in this mode, the tool won't even try to connect the server leaving
 unavailable data unavailable.
 Hence, the API should have a way to communicate what information is missing
\begin_inset Foot
collapsed false

\layout Standard

Mainly, this is missing revision ranges.
\end_inset 

.
 Moreover, outdated information must not be deleted as long as there is
 no way to replace it.
\layout Subsection

Refresh Log Information
\layout Standard

In some environments, a user is allowed to modify comment, author and time
 stamp revision properties of some or all revisions.
 This may happen more or less infrequently and may or may not be of interest
 to other users.
 Note that generally important status information should be stored in dedicated
 revision properties.
\layout Standard

Hence, refreshing the log cache is a very infrequent operation and the user
 must enable and trigger it explicitly.
 Because there is no way of knowing the revisions that were actually changed
 and fetching only the log header is takes almost as long as fetching the
 verbose log, a refresh may be implemented as a simple 
\begin_inset Quotes sld
\end_inset 

clear cache
\begin_inset Quotes srd
\end_inset 

 operation.
\layout Subsection

Enhanced Diff Between Tags
\layout Standard

When asking SVN between to arbitrary paths, it will not only use ancestry
 information but will also compare contents to check if the files are actually
 different.
 Changes that have been undone later on will not show up in the result.
 
\layout Standard

Some users may want more detail here: were there further changes in the
 past that don't show up in the final diff? What is the change history down
 to the common ancester of a given item?
\layout Standard

Log information is sufficient to construct the list of nodes that have been
 touched on any side.
 The search will stop for those paths that found a common ancestor.
 So, the locally cached log data can be used for limited offline diffs as
 well as for enhancing online diffs by adding a list of 
\begin_inset Quotes sld
\end_inset 

touched
\begin_inset Quotes srd
\end_inset 

 paths that did end up with the same content, though.
\layout Subsection

Quality Assurance
\layout Standard

Statistics already cover some quality assurance tasks.
 Starting from that aggregated data, the user queries specific sub-sets
 and correlates them to each other
\begin_inset Foot
collapsed false

\layout Standard

Examples: Does someone frequently add / remove source files without updating
 the respective project file? Are short comments used mainly used for small
 commits? After large merges, how many 
\begin_inset Quotes sld
\end_inset 

fix build
\begin_inset Quotes srd
\end_inset 

 commits are required to stabilize the target path again?
\end_inset 

.
 The goal here is to find systematic problems.
\layout Standard

Another type of log analysis has the form of 
\begin_inset Quotes sld
\end_inset 

What paths (branches / tags) contain a certain code fragment?
\begin_inset Quotes srd
\end_inset 


\begin_inset Foot
collapsed false

\layout Standard

Note, that there is a multitude of possible options and parameters to be
 passed to that query.
\end_inset 

 There may be various types of similar questions that cannot be answered
 by a simple 
\family typewriter 
diff
\family default 
, 
\family typewriter 
log
\family default 
 or 
\family typewriter 
blame
\family default 
 command but requires their interactive use: 
\family typewriter 
blame
\family default 
 and 
\family typewriter 
log
\family default 
 will allow to trace back to the origin of the code fragment.
 
\family typewriter 
Log
\family default 
 will then be used to find candidates that may still contain some or all
 of these lines with 
\family typewriter 
diff
\family default 
 verifying that modifications did not change the code lines in question.
 Since there is probably no other way than examining many log entries one
 by one, the log cache performance is crucial.
\layout Standard

QA analysis queries will often be automated.
 Hence, some command line or similar scripting interface is desirable.
\layout Subsection

Honor Access Rights
\layout Standard

The user may not have full access rights.
 In the first place, this applies to the repository itself: Even if someone
 provided the working copy, the current user may not have the right to access
 any of the corresponding repository paths.
 When asking the server for a particular log, we must, therefore, pass just
 the same path that the user specified
\begin_inset Foot
collapsed false

\layout Standard

It is not generally possible to resort to the repository root, for instance.
\end_inset 

.
 As a result, the log cache will not contain just one consecutive range
 of revisions.
 Moreover, the revision ranges must be tagged with the paths that have been
 used to get the log from the server.
 The latter will not be asked again for those missing revisions in between.
\layout Standard

Once the log cache grows a background 
\begin_inset Quotes sld
\end_inset 

auto-fill
\begin_inset Quotes srd
\end_inset 

 feature, there must be an option to exclude / include repository paths.
 Otherwise, there would be a lot of 
\begin_inset Quotes sld
\end_inset 

access denied
\begin_inset Quotes srd
\end_inset 

 to be found in the server access logs.
 However, no revision shall be removed from the log cache if the changed
 paths are no longer accessible by the user
\begin_inset Foot
collapsed false

\layout Standard

Rationale: The information already leaked, obviously.
 Furthermore, there may be a temporary issue with the server returning bogous
 errors and the user doesn't want to lose all his / her cache content in
 that case.
\end_inset 

.
\layout Standard

A second type of access right management applies to the placement of the
 log cache data.
 Some users may want to share it with others on the same machine.
 Other users may - by company rules - not at all be allowed to do that.
\layout Section

System Requirements
\layout Standard

This section will derive requirements from on the use cases listed above,
 that the log caching mechanism shall meet.
\layout Subsection

Functional 
\layout Standard

XML I/O
\layout Subsection

Non-functional
\layout Standard

To be used at all, the cache shall have an acceptable RAM and disk footprint.
 Operation from cache would ideally be interactively, i.e.
 the tool would answer faster than the user is able to make up his mind
 about the next step.
 Worst case performance should be close to traditional, non-cached operation.
\layout Subsubsection

Scalability and Worst Case
\layout Standard

Repository growth is limited by human activity
\begin_inset Foot
collapsed false

\layout Standard

Monitoring fully automated systems like system snapshots every ten seconds
 are not in the scope of TortoiseSVN.
\end_inset 

: The number of check-ins as well as the number of changes per check-in
 will be about constant for each individual person.
 Indirectly, this is even true for repositories that contain mainly third
 party code, e.g.
 LINUX distributions, because in the end those files stem from 
\begin_inset Quotes sld
\end_inset 

ordinary
\begin_inset Quotes srd
\end_inset 

 repositories.
\layout Standard

Hence, we may assume that the number of path changes per unit of time will
 increase but slowly if at all.
 Moore's law does not apply here.
 Therefore, a reasonable worst-case scenario for a single repository would
 be:
\layout Itemize

about 1 commit per minute (500k revisions per year, equivalent to approx.
 500 full-time developers)
\layout Itemize

10 million revisions in 20 years
\layout Itemize

100 million changed paths in 20 years
\layout Itemize

1000 million words commentary in 20 years
\layout Standard

For the short term, users will stick with 32 bit systems limiting the usable
 address space to a few 100 megs
\begin_inset Foot
collapsed false

\layout Standard

Mind the address space fragmentation!
\end_inset 

.
 It may not be possible to cover the long-term worst case with that limited
 amount of RAM.
 Therefore, we reduce the requirement by a factor of 10 for those systems.
\layout Subsubsection

Size
\layout Standard

Given an estimated average of less than 10 paths changed per revision, the
 size of the XML log data is 1 kByte or less per revision for typical repositori
es
\begin_inset Foot
collapsed false

\layout Standard

Actual samples: apache.org (1032 bytes), kde.org (963 bytes), TortoiseSVN
 (451 bytes).
\end_inset 

.
 They will soon grow to one GByte and more for the largest repositories.
 
\layout Standard

Fortunately, those XML files contain highly redundant information: they
 can be ZIPed to about one 15th of their original size.
 A ratio of 1:10 would reduce the file size to a managable 100 MByte.
 With additional temporary indices, pointers and so forth, the in-memory
 representation may be twice as big.
\layout Standard

General target cache data sizes:
\layout Itemize

on disk ten times better than 
\family typewriter 
svn log -v --xml
\layout Itemize

in RAM five times better than 
\family typewriter 
svn log -v --xml
\layout Standard

Our benchmark will the revisions 1 through 500,000 of kde.org.
 The XML file is 459 MByte and the corresponding cache size shall be less
 than 50 MByte on disk and less than 100 MByte in memory, respectively.
 
\layout Subsubsection

Performance
\layout Itemize

100 MB/s from file cache
\layout Subsubsection

Robustness
\layout Standard

Checksum, write & replace.
\layout Subsubsection

Extensibility
\layout Standard

Things that can be added without breaking storage format compatibility:
\layout Itemize

Indices
\layout Standard

Things that can be added without breaking the design:
\layout Itemize

Data stream formats.
\layout Section

Big Picture Design
\layout Standard

.
\layout Section

Detailed Design
\layout Standard

.
\the_end
