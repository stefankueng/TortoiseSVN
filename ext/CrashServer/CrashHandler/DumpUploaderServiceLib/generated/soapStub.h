/* soapStub.h
   Generated by gSOAP 2.8.17r from DumpUploader.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2   "https://www.drdump.com/services/Imports"
#define SOAP_NAMESPACE_OF_ns1   "https://www.drdump.com/services"
#define SOAP_NAMESPACE_OF_ns3   "http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_ns4   "http://schemas.datacontract.org/2004/07/DumpUploadService3"
#define SOAP_NAMESPACE_OF_ns5   "http://schemas.microsoft.com/2003/10/Serialization/Arrays"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20817
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns4__ClientLib_Architecture
#define SOAP_TYPE_ns4__ClientLib_Architecture (86)
/* ns4:ClientLib.Architecture */
enum ns4__ClientLib_Architecture { ns4__ClientLib_Architecture__x86 = 0, ns4__ClientLib_Architecture__x64 = 1, ns4__ClientLib_Architecture__DotNet = 2 };
#endif

#ifndef SOAP_TYPE_ns4__ClientLib_ClientType
#define SOAP_TYPE_ns4__ClientLib_ClientType (88)
/* ns4:ClientLib.ClientType */
enum ns4__ClientLib_ClientType { ns4__ClientLib_ClientType__CrashHandler_1_0 = 0, ns4__ClientLib_ClientType__WebCrashRptGate = 1, ns4__ClientLib_ClientType__DumpUploader = 2, ns4__ClientLib_ClientType__CrashHandler_2_0_CrashRptBased = 3, ns4__ClientLib_ClientType__SymbolUploader = 4 };
#endif

#ifndef SOAP_TYPE_ns4__HaveSolutionResponse_SolutionType
#define SOAP_TYPE_ns4__HaveSolutionResponse_SolutionType (90)
/* ns4:HaveSolutionResponse.SolutionType */
enum ns4__HaveSolutionResponse_SolutionType { ns4__HaveSolutionResponse_SolutionType__Url = 0, ns4__HaveSolutionResponse_SolutionType__Exe = 1 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (11)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
    char *__item;
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_xsd__anyType */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__anyType() { xsd__anyType::soap_default(NULL); }
    virtual ~xsd__anyType() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (12)
/* Base64 schema type: */
struct _xop__Include
{
public:
    unsigned char *__ptr;
    int __size;
    char *id;   /* optional element of type xsd:string */
    char *type; /* optional element of type xsd:string */
    char *options;  /* optional element of type xsd:string */
public:
    int soap_type() const { return 12; } /* = unique type id SOAP_TYPE__xop__Include */
};
typedef struct _xop__Include _xop__Include;
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (20)
/* Primitive xsd:ID schema type: */
class SOAP_CMAC xsd__ID_ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE_xsd__ID_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__ID_() { xsd__ID_::soap_default(NULL); }
    virtual ~xsd__ID_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (22)
/* Primitive xsd:IDREF schema type: */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_xsd__IDREF_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__IDREF_() { xsd__IDREF_::soap_default(NULL); }
    virtual ~xsd__IDREF_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (23)
/* Primitive xsd:QName schema type: */
class SOAP_CMAC xsd__QName_ : public xsd__anyType
{
public:
    std::string __item;
public:
    virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_xsd__QName_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__QName_() { xsd__QName_::soap_default(NULL); }
    virtual ~xsd__QName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (25)
/* Primitive xsd:anyURI schema type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_xsd__anyURI_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
    virtual ~xsd__anyURI_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (26)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary : public xsd__anyType
{
public:
    struct _xop__Include __item;
public:
    virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
    virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (27)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
    bool __item;
public:
    virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_xsd__boolean */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__boolean() { xsd__boolean::soap_default(NULL); }
    virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (29)
/* Primitive xsd:byte schema type: */
class SOAP_CMAC xsd__byte_ : public xsd__anyType
{
public:
    char __item;
public:
    virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_xsd__byte_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__byte_() { xsd__byte_::soap_default(NULL); }
    virtual ~xsd__byte_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (30)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
    time_t __item;
public:
    virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_xsd__dateTime */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
    virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (33)
/* Primitive xsd:decimal schema type: */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_xsd__decimal_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__decimal_() { xsd__decimal_::soap_default(NULL); }
    virtual ~xsd__decimal_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (34)
/* Primitive xsd:double schema type: */
class SOAP_CMAC xsd__double : public xsd__anyType
{
public:
    double __item;
public:
    virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_xsd__double */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__double() { xsd__double::soap_default(NULL); }
    virtual ~xsd__double() { }
};
#endif

#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (37)
/* Primitive xsd:duration schema type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_xsd__duration_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__duration_() { xsd__duration_::soap_default(NULL); }
    virtual ~xsd__duration_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (38)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
    float __item;
public:
    virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_xsd__float */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__float() { xsd__float::soap_default(NULL); }
    virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (40)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
    int __item;
public:
    virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE_xsd__int */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__int() { xsd__int::soap_default(NULL); }
    virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (41)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
    LONG64 __item;
public:
    virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_xsd__long */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__long() { xsd__long::soap_default(NULL); }
    virtual ~xsd__long() { }
};
#endif

#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (43)
/* Primitive xsd:short schema type: */
class SOAP_CMAC xsd__short : public xsd__anyType
{
public:
    short __item;
public:
    virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_xsd__short */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__short() { xsd__short::soap_default(NULL); }
    virtual ~xsd__short() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (45)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_xsd__string */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__string() { xsd__string::soap_default(NULL); }
    virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (46)
/* Primitive xsd:unsignedByte schema type: */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType
{
public:
    unsigned char __item;
public:
    virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_xsd__unsignedByte_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__unsignedByte_() { xsd__unsignedByte_::soap_default(NULL); }
    virtual ~xsd__unsignedByte_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (47)
/* Primitive xsd:unsignedInt schema type: */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType
{
public:
    unsigned int __item;
public:
    virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_xsd__unsignedInt */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__unsignedInt() { xsd__unsignedInt::soap_default(NULL); }
    virtual ~xsd__unsignedInt() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (48)
/* Primitive xsd:unsignedLong schema type: */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType
{
public:
    ULONG64 __item;
public:
    virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_xsd__unsignedLong */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__unsignedLong() { xsd__unsignedLong::soap_default(NULL); }
    virtual ~xsd__unsignedLong() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (50)
/* Primitive xsd:unsignedShort schema type: */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType
{
public:
    unsigned short __item;
public:
    virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_xsd__unsignedShort */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             xsd__unsignedShort() { xsd__unsignedShort::soap_default(NULL); }
    virtual ~xsd__unsignedShort() { }
};
#endif

#ifndef SOAP_TYPE_ns3__char__
#define SOAP_TYPE_ns3__char__ (81)
/* Primitive ns3:char schema type: */
class SOAP_CMAC ns3__char__ : public xsd__anyType
{
public:
    int __item;
public:
    virtual int soap_type() const { return 81; } /* = unique type id SOAP_TYPE_ns3__char__ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns3__char__() { ns3__char__::soap_default(NULL); }
    virtual ~ns3__char__() { }
};
#endif

#ifndef SOAP_TYPE_ns3__duration__
#define SOAP_TYPE_ns3__duration__ (83)
/* Primitive ns3:duration schema type: */
class SOAP_CMAC ns3__duration__ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 83; } /* = unique type id SOAP_TYPE_ns3__duration__ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns3__duration__() { ns3__duration__::soap_default(NULL); }
    virtual ~ns3__duration__() { }
};
#endif

#ifndef SOAP_TYPE_ns3__guid__
#define SOAP_TYPE_ns3__guid__ (85)
/* Primitive ns3:guid schema type: */
class SOAP_CMAC ns3__guid__ : public xsd__anyType
{
public:
    std::wstring __item;
public:
    virtual int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_ns3__guid__ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns3__guid__() { ns3__guid__::soap_default(NULL); }
    virtual ~ns3__guid__() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ClientLib_Architecture_
#define SOAP_TYPE_ns4__ClientLib_Architecture_ (87)
/* Primitive ns4:ClientLib.Architecture schema type: */
class SOAP_CMAC ns4__ClientLib_Architecture_ : public xsd__anyType
{
public:
    enum ns4__ClientLib_Architecture __item;
public:
    virtual int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_ns4__ClientLib_Architecture_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns4__ClientLib_Architecture_() { ns4__ClientLib_Architecture_::soap_default(NULL); }
    virtual ~ns4__ClientLib_Architecture_() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ClientLib_ClientType_
#define SOAP_TYPE_ns4__ClientLib_ClientType_ (89)
/* Primitive ns4:ClientLib.ClientType schema type: */
class SOAP_CMAC ns4__ClientLib_ClientType_ : public xsd__anyType
{
public:
    enum ns4__ClientLib_ClientType __item;
public:
    virtual int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_ns4__ClientLib_ClientType_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns4__ClientLib_ClientType_() { ns4__ClientLib_ClientType_::soap_default(NULL); }
    virtual ~ns4__ClientLib_ClientType_() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HaveSolutionResponse_SolutionType_
#define SOAP_TYPE_ns4__HaveSolutionResponse_SolutionType_ (91)
/* Primitive ns4:HaveSolutionResponse.SolutionType schema type: */
class SOAP_CMAC ns4__HaveSolutionResponse_SolutionType_ : public xsd__anyType
{
public:
    enum ns4__HaveSolutionResponse_SolutionType __item;
public:
    virtual int soap_type() const { return 91; } /* = unique type id SOAP_TYPE_ns4__HaveSolutionResponse_SolutionType_ */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns4__HaveSolutionResponse_SolutionType_() { ns4__HaveSolutionResponse_SolutionType_::soap_default(NULL); }
    virtual ~ns4__HaveSolutionResponse_SolutionType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ClientLib
#define SOAP_TYPE_ns1__ClientLib (52)
/* ns1:ClientLib */
class SOAP_CMAC ns1__ClientLib : public xsd__anyType
{
public:
    enum ns4__ClientLib_Architecture arch;  /* required element of type ns4:ClientLib.Architecture */
    enum ns4__ClientLib_ClientType type;    /* required element of type ns4:ClientLib.ClientType */
    unsigned short v1;  /* required element of type xsd:unsignedShort */
    unsigned short v2;  /* required element of type xsd:unsignedShort */
    unsigned short v3;  /* required element of type xsd:unsignedShort */
    unsigned short v4;  /* required element of type xsd:unsignedShort */
public:
    virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_ns1__ClientLib */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__ClientLib() { ns1__ClientLib::soap_default(NULL); }
    virtual ~ns1__ClientLib() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Application
#define SOAP_TYPE_ns1__Application (53)
/* ns1:Application */
class SOAP_CMAC ns1__Application : public xsd__anyType
{
public:
    std::wstring applicationGUID;   /* required element of type ns3:guid */
    unsigned short hotfix;  /* required element of type xsd:unsignedShort */
    std::wstring *mainModule;   /* optional element of type xsd:string */
    unsigned short v1;  /* required element of type xsd:unsignedShort */
    unsigned short v2;  /* required element of type xsd:unsignedShort */
    unsigned short v3;  /* required element of type xsd:unsignedShort */
    unsigned short v4;  /* required element of type xsd:unsignedShort */
public:
    virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_ns1__Application */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__Application() { ns1__Application::soap_default(NULL); }
    virtual ~ns1__Application() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AppAdditionalInfo
#define SOAP_TYPE_ns1__AppAdditionalInfo (54)
/* ns1:AppAdditionalInfo */
class SOAP_CMAC ns1__AppAdditionalInfo : public xsd__anyType
{
public:
    std::wstring *appName;  /* optional element of type xsd:string */
    std::wstring *companyName;  /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_ns1__AppAdditionalInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__AppAdditionalInfo() { ns1__AppAdditionalInfo::soap_default(NULL); }
    virtual ~ns1__AppAdditionalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DumpAdditionalInfo
#define SOAP_TYPE_ns1__DumpAdditionalInfo (55)
/* ns1:DumpAdditionalInfo */
class SOAP_CMAC ns1__DumpAdditionalInfo : public xsd__anyType
{
public:
    int PCID;   /* required element of type xsd:int */
    time_t crashDate;   /* required element of type xsd:dateTime */
    std::wstring *description;  /* optional element of type xsd:string */
    std::wstring *group;    /* optional element of type xsd:string */
    int submitterID;    /* required element of type xsd:int */
public:
    virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_ns1__DumpAdditionalInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__DumpAdditionalInfo() { ns1__DumpAdditionalInfo::soap_default(NULL); }
    virtual ~ns1__DumpAdditionalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfModuleSymbolInfo
#define SOAP_TYPE_ns1__ArrayOfModuleSymbolInfo (56)
/* ns1:ArrayOfModuleSymbolInfo */
class SOAP_CMAC ns1__ArrayOfModuleSymbolInfo : public xsd__anyType
{
public:
    std::vector<class ns1__ModuleSymbolInfo * >ModuleSymbolInfo;    /* optional element of type ns1:ModuleSymbolInfo */
public:
    virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_ns1__ArrayOfModuleSymbolInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__ArrayOfModuleSymbolInfo() { ns1__ArrayOfModuleSymbolInfo::soap_default(NULL); }
    virtual ~ns1__ArrayOfModuleSymbolInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ModuleSymbolInfo
#define SOAP_TYPE_ns1__ModuleSymbolInfo (57)
/* ns1:ModuleSymbolInfo */
class SOAP_CMAC ns1__ModuleSymbolInfo : public xsd__anyType
{
public:
    bool isMicrosoftModule; /* required element of type xsd:boolean */
    std::wstring *path; /* optional element of type xsd:string */
    class ns1__Pdb70File *pdb;  /* optional element of type ns1:Pdb70File */
    unsigned int sizeOfImage;   /* required element of type xsd:unsignedInt */
    unsigned int timeDateStamp; /* required element of type xsd:unsignedInt */
public:
    virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_ns1__ModuleSymbolInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__ModuleSymbolInfo() { ns1__ModuleSymbolInfo::soap_default(NULL); }
    virtual ~ns1__ModuleSymbolInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Pdb70File
#define SOAP_TYPE_ns1__Pdb70File (58)
/* ns1:Pdb70File */
class SOAP_CMAC ns1__Pdb70File : public xsd__anyType
{
public:
    unsigned int age;   /* required element of type xsd:unsignedInt */
    std::wstring *path; /* optional element of type xsd:string */
    std::wstring signature; /* required element of type ns3:guid */
public:
    virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_ns1__Pdb70File */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__Pdb70File() { ns1__Pdb70File::soap_default(NULL); }
    virtual ~ns1__Pdb70File() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Response
#define SOAP_TYPE_ns1__Response (59)
/* ns1:Response */
class SOAP_CMAC ns1__Response : public xsd__anyType
{
public:
    std::wstring *clientID; /* optional element of type xsd:string */
    struct _xop__Include *context;  /* optional element of type xop:Include */
    int *dumpGroupID;   /* optional element of type xsd:int */
    int *dumpID;    /* optional element of type xsd:int */
    struct _xop__Include *garbage;  /* optional element of type xop:Include */
    int *problemID; /* optional element of type xsd:int */
    std::wstring *urlToProblem; /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_ns1__Response */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__Response() { ns1__Response::soap_default(NULL); }
    virtual ~ns1__Response() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Hello
#define SOAP_TYPE__ns1__Hello (67)
/* ns1:Hello */
class SOAP_CMAC _ns1__Hello
{
public:
    ns1__ClientLib *clientLib;  /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    ns1__AppAdditionalInfo *appAddInfo; /* optional element of type ns1:AppAdditionalInfo */
    ns1__DumpAdditionalInfo *addInfo;   /* optional element of type ns1:DumpAdditionalInfo */
    ns1__ArrayOfModuleSymbolInfo *availableSymbols; /* optional element of type ns1:ArrayOfModuleSymbolInfo */
    struct _xop__Include *stack;    /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE__ns1__Hello */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__Hello() { _ns1__Hello::soap_default(NULL); }
    virtual ~_ns1__Hello() { }
};
#endif

#ifndef SOAP_TYPE__ns1__HelloResponse
#define SOAP_TYPE__ns1__HelloResponse (68)
/* ns1:HelloResponse */
class SOAP_CMAC _ns1__HelloResponse
{
public:
    ns1__Response *HelloResult; /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type ns1:Response */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE__ns1__HelloResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__HelloResponse() { _ns1__HelloResponse::soap_default(NULL); }
    virtual ~_ns1__HelloResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadMiniDump
#define SOAP_TYPE__ns1__UploadMiniDump (69)
/* ns1:UploadMiniDump */
class SOAP_CMAC _ns1__UploadMiniDump
{
public:
    ns1__ClientLib *client; /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    ns1__DumpAdditionalInfo *addInfo;   /* optional element of type ns1:DumpAdditionalInfo */
    struct _xop__Include *dump; /* optional element of type xop:Include */
    struct _xop__Include *context;  /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE__ns1__UploadMiniDump */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadMiniDump() { _ns1__UploadMiniDump::soap_default(NULL); }
    virtual ~_ns1__UploadMiniDump() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadMiniDumpResponse
#define SOAP_TYPE__ns1__UploadMiniDumpResponse (70)
/* ns1:UploadMiniDumpResponse */
class SOAP_CMAC _ns1__UploadMiniDumpResponse
{
public:
    ns1__Response *UploadMiniDumpResult;    /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type ns1:Response */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE__ns1__UploadMiniDumpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadMiniDumpResponse() { _ns1__UploadMiniDumpResponse::soap_default(NULL); }
    virtual ~_ns1__UploadMiniDumpResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadFullDump
#define SOAP_TYPE__ns1__UploadFullDump (71)
/* ns1:UploadFullDump */
class SOAP_CMAC _ns1__UploadFullDump
{
public:
    ns1__ClientLib *client; /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    int *miniDumpID;    /* optional element of type xsd:int */
    struct _xop__Include *dumpInZip;    /* optional element of type xop:Include */
    struct _xop__Include *context;  /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE__ns1__UploadFullDump */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadFullDump() { _ns1__UploadFullDump::soap_default(NULL); }
    virtual ~_ns1__UploadFullDump() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadFullDumpResponse
#define SOAP_TYPE__ns1__UploadFullDumpResponse (72)
/* ns1:UploadFullDumpResponse */
class SOAP_CMAC _ns1__UploadFullDumpResponse
{
public:
    ns1__Response *UploadFullDumpResult;    /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type ns1:Response */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE__ns1__UploadFullDumpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadFullDumpResponse() { _ns1__UploadFullDumpResponse::soap_default(NULL); }
    virtual ~_ns1__UploadFullDumpResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadAdditionalInfo
#define SOAP_TYPE__ns1__UploadAdditionalInfo (73)
/* ns1:UploadAdditionalInfo */
class SOAP_CMAC _ns1__UploadAdditionalInfo
{
public:
    ns1__ClientLib *client; /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    int *miniDumpID;    /* optional element of type xsd:int */
    struct _xop__Include *info; /* optional element of type xop:Include */
    struct _xop__Include *context;  /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE__ns1__UploadAdditionalInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadAdditionalInfo() { _ns1__UploadAdditionalInfo::soap_default(NULL); }
    virtual ~_ns1__UploadAdditionalInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadAdditionalInfoResponse
#define SOAP_TYPE__ns1__UploadAdditionalInfoResponse (74)
/* ns1:UploadAdditionalInfoResponse */
class SOAP_CMAC _ns1__UploadAdditionalInfoResponse
{
public:
    ns1__Response *UploadAdditionalInfoResult;  /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type ns1:Response */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE__ns1__UploadAdditionalInfoResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadAdditionalInfoResponse() { _ns1__UploadAdditionalInfoResponse::soap_default(NULL); }
    virtual ~_ns1__UploadAdditionalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RejectedToSendAdditionalInfo
#define SOAP_TYPE__ns1__RejectedToSendAdditionalInfo (75)
/* ns1:RejectedToSendAdditionalInfo */
class SOAP_CMAC _ns1__RejectedToSendAdditionalInfo
{
public:
    ns1__ClientLib *client; /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    int *miniDumpID;    /* optional element of type xsd:int */
    struct _xop__Include *context;  /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE__ns1__RejectedToSendAdditionalInfo */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__RejectedToSendAdditionalInfo() { _ns1__RejectedToSendAdditionalInfo::soap_default(NULL); }
    virtual ~_ns1__RejectedToSendAdditionalInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RejectedToSendAdditionalInfoResponse
#define SOAP_TYPE__ns1__RejectedToSendAdditionalInfoResponse (76)
/* ns1:RejectedToSendAdditionalInfoResponse */
class SOAP_CMAC _ns1__RejectedToSendAdditionalInfoResponse
{
public:
    ns1__Response *RejectedToSendAdditionalInfoResult;  /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type ns1:Response */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE__ns1__RejectedToSendAdditionalInfoResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__RejectedToSendAdditionalInfoResponse() { _ns1__RejectedToSendAdditionalInfoResponse::soap_default(NULL); }
    virtual ~_ns1__RejectedToSendAdditionalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadSymbol
#define SOAP_TYPE__ns1__UploadSymbol (77)
/* ns1:UploadSymbol */
class SOAP_CMAC _ns1__UploadSymbol
{
public:
    ns1__ClientLib *client; /* optional element of type ns1:ClientLib */
    ns1__Application *app;  /* optional element of type ns1:Application */
    bool *publish;  /* optional element of type xsd:boolean */
    struct _xop__Include *sym;  /* optional element of type xop:Include */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE__ns1__UploadSymbol */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadSymbol() { _ns1__UploadSymbol::soap_default(NULL); }
    virtual ~_ns1__UploadSymbol() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadSymbolResponse
#define SOAP_TYPE__ns1__UploadSymbolResponse (78)
/* ns1:UploadSymbolResponse */
class SOAP_CMAC _ns1__UploadSymbolResponse
{
public:
    std::wstring *UploadSymbolResult;   /* SOAP 1.2 RPC return element (when namespace qualified) */    /* optional element of type xsd:string */
    struct soap *soap;  /* transient */
public:
    virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE__ns1__UploadSymbolResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             _ns1__UploadSymbolResponse() { _ns1__UploadSymbolResponse::soap_default(NULL); }
    virtual ~_ns1__UploadSymbolResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfstring
#define SOAP_TYPE_ns5__ArrayOfstring (79)
/* ns5:ArrayOfstring */
class SOAP_CMAC ns5__ArrayOfstring : public xsd__anyType
{
public:
    std::vector<std::wstring >string;   /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_ns5__ArrayOfstring */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns5__ArrayOfstring() { ns5__ArrayOfstring::soap_default(NULL); }
    virtual ~ns5__ArrayOfstring() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StopResponse
#define SOAP_TYPE_ns1__StopResponse (60)
/* ns1:StopResponse */
class SOAP_CMAC ns1__StopResponse : public ns1__Response
{
public:
    virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_ns1__StopResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__StopResponse() { ns1__StopResponse::soap_default(NULL); }
    virtual ~ns1__StopResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ErrorResponse
#define SOAP_TYPE_ns1__ErrorResponse (61)
/* ns1:ErrorResponse */
class SOAP_CMAC ns1__ErrorResponse : public ns1__Response
{
public:
    std::wstring *error;    /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_ns1__ErrorResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__ErrorResponse() { ns1__ErrorResponse::soap_default(NULL); }
    virtual ~ns1__ErrorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HaveSolutionResponse
#define SOAP_TYPE_ns1__HaveSolutionResponse (62)
/* ns1:HaveSolutionResponse */
class SOAP_CMAC ns1__HaveSolutionResponse : public ns1__Response
{
public:
    bool askConfirmation;   /* required element of type xsd:boolean */
    struct _xop__Include *exe;  /* optional element of type xop:Include */
    enum ns4__HaveSolutionResponse_SolutionType type;   /* required element of type ns4:HaveSolutionResponse.SolutionType */
    std::wstring *url;  /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_ns1__HaveSolutionResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__HaveSolutionResponse() { ns1__HaveSolutionResponse::soap_default(NULL); }
    virtual ~ns1__HaveSolutionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NeedSymbolsThenMiniDumpResponse
#define SOAP_TYPE_ns1__NeedSymbolsThenMiniDumpResponse (63)
/* ns1:NeedSymbolsThenMiniDumpResponse */
class SOAP_CMAC ns1__NeedSymbolsThenMiniDumpResponse : public ns1__Response
{
public:
    bool askConfirmation;   /* required element of type xsd:boolean */
    ns5__ArrayOfstring *msSymbols;  /* optional element of type ns5:ArrayOfstring */
    ns5__ArrayOfstring *symbols;    /* optional element of type ns5:ArrayOfstring */
public:
    virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_ns1__NeedSymbolsThenMiniDumpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__NeedSymbolsThenMiniDumpResponse() { ns1__NeedSymbolsThenMiniDumpResponse::soap_default(NULL); }
    virtual ~ns1__NeedSymbolsThenMiniDumpResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NeedMiniDumpResponse
#define SOAP_TYPE_ns1__NeedMiniDumpResponse (64)
/* ns1:NeedMiniDumpResponse */
class SOAP_CMAC ns1__NeedMiniDumpResponse : public ns1__Response
{
public:
    virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_ns1__NeedMiniDumpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__NeedMiniDumpResponse() { ns1__NeedMiniDumpResponse::soap_default(NULL); }
    virtual ~ns1__NeedMiniDumpResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NeedFullDumpResponse
#define SOAP_TYPE_ns1__NeedFullDumpResponse (65)
/* ns1:NeedFullDumpResponse */
class SOAP_CMAC ns1__NeedFullDumpResponse : public ns1__Response
{
public:
    bool attachUserInfo;    /* required element of type xsd:boolean */
    unsigned int restrictedDumpType;    /* required element of type xsd:unsignedInt */
public:
    virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_ns1__NeedFullDumpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__NeedFullDumpResponse() { ns1__NeedFullDumpResponse::soap_default(NULL); }
    virtual ~ns1__NeedFullDumpResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NeedMoreInfoResponse
#define SOAP_TYPE_ns1__NeedMoreInfoResponse (66)
/* ns1:NeedMoreInfoResponse */
class SOAP_CMAC ns1__NeedMoreInfoResponse : public ns1__Response
{
public:
    struct _xop__Include *infoModule;   /* optional element of type xop:Include */
    std::wstring *infoModuleCfg;    /* optional element of type xsd:string */
public:
    virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_ns1__NeedMoreInfoResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);
             ns1__NeedMoreInfoResponse() { ns1__NeedMoreInfoResponse::soap_default(NULL); }
    virtual ~ns1__NeedMoreInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__Hello
#define SOAP_TYPE___ns1__Hello (110)
/* Operation wrapper: */
struct __ns1__Hello
{
public:
    _ns1__Hello *ns1__Hello;    /* optional element of type ns1:Hello */
public:
    int soap_type() const { return 110; } /* = unique type id SOAP_TYPE___ns1__Hello */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadMiniDump
#define SOAP_TYPE___ns1__UploadMiniDump (114)
/* Operation wrapper: */
struct __ns1__UploadMiniDump
{
public:
    _ns1__UploadMiniDump *ns1__UploadMiniDump;  /* optional element of type ns1:UploadMiniDump */
public:
    int soap_type() const { return 114; } /* = unique type id SOAP_TYPE___ns1__UploadMiniDump */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadFullDump
#define SOAP_TYPE___ns1__UploadFullDump (118)
/* Operation wrapper: */
struct __ns1__UploadFullDump
{
public:
    _ns1__UploadFullDump *ns1__UploadFullDump;  /* optional element of type ns1:UploadFullDump */
public:
    int soap_type() const { return 118; } /* = unique type id SOAP_TYPE___ns1__UploadFullDump */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadAdditionalInfo
#define SOAP_TYPE___ns1__UploadAdditionalInfo (122)
/* Operation wrapper: */
struct __ns1__UploadAdditionalInfo
{
public:
    _ns1__UploadAdditionalInfo *ns1__UploadAdditionalInfo;  /* optional element of type ns1:UploadAdditionalInfo */
public:
    int soap_type() const { return 122; } /* = unique type id SOAP_TYPE___ns1__UploadAdditionalInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__RejectedToSendAdditionalInfo
#define SOAP_TYPE___ns1__RejectedToSendAdditionalInfo (126)
/* Operation wrapper: */
struct __ns1__RejectedToSendAdditionalInfo
{
public:
    _ns1__RejectedToSendAdditionalInfo *ns1__RejectedToSendAdditionalInfo;  /* optional element of type ns1:RejectedToSendAdditionalInfo */
public:
    int soap_type() const { return 126; } /* = unique type id SOAP_TYPE___ns1__RejectedToSendAdditionalInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadSymbol
#define SOAP_TYPE___ns1__UploadSymbol (130)
/* Operation wrapper: */
struct __ns1__UploadSymbol
{
public:
    _ns1__UploadSymbol *ns1__UploadSymbol;  /* optional element of type ns1:UploadSymbol */
public:
    int soap_type() const { return 130; } /* = unique type id SOAP_TYPE___ns1__UploadSymbol */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (131)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
    int soap_type() const { return 131; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
    char dummy; /* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (132)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
    char *SOAP_ENV__Value;  /* optional element of type xsd:QName */
    struct SOAP_ENV__Code *SOAP_ENV__Subcode;   /* optional element of type SOAP-ENV:Code */
public:
    int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (134)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
    char *__any;
    int __type; /* any type of element <fault> (defined below) */
    void *fault;    /* transient */
public:
    int soap_type() const { return 134; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (137)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
    char *SOAP_ENV__Text;   /* optional element of type xsd:string */
public:
    int soap_type() const { return 137; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (138)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
    char *faultcode;    /* optional element of type xsd:QName */
    char *faultstring;  /* optional element of type xsd:string */
    char *faultactor;   /* optional element of type xsd:string */
    struct SOAP_ENV__Detail *detail;    /* optional element of type SOAP-ENV:Detail */
    struct SOAP_ENV__Code *SOAP_ENV__Code;  /* optional element of type SOAP-ENV:Code */
    struct SOAP_ENV__Reason *SOAP_ENV__Reason;  /* optional element of type SOAP-ENV:Reason */
    char *SOAP_ENV__Node;   /* optional element of type xsd:string */
    char *SOAP_ENV__Role;   /* optional element of type xsd:string */
    struct SOAP_ENV__Detail *SOAP_ENV__Detail;  /* optional element of type SOAP-ENV:Detail */
public:
    int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (16)
typedef char xsd__byte;
#endif

#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (17)
typedef unsigned char xsd__unsignedByte;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (19)
typedef std::wstring xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (21)
typedef std::wstring xsd__IDREF;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (24)
typedef std::wstring xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (32)
typedef std::wstring xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (36)
typedef std::wstring xsd__duration;
#endif

#ifndef SOAP_TYPE_ns3__char
#define SOAP_TYPE_ns3__char (80)
typedef int ns3__char;
#endif

#ifndef SOAP_TYPE_ns3__duration
#define SOAP_TYPE_ns3__duration (82)
typedef std::wstring ns3__duration;
#endif

#ifndef SOAP_TYPE_ns3__guid
#define SOAP_TYPE_ns3__guid (84)
typedef std::wstring ns3__guid;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
