Index: be_all_s.c
===================================================================
--- be_all_s.c	(revision 28540)
+++ be_all_s.c	(working copy)
@@ -14,7 +14,7 @@
  * have tiny little source modules containing nothing but
  * declarations of appname, for as long as I can...
  */
-const char *const appname = "PuTTY";
+const char *const appname = "TortoisePlink";
 
 #ifdef TELNET_DEFAULT
 const int be_default_protocol = PROT_TELNET;
Index: cmdline.c
===================================================================
--- cmdline.c	(revision 28540)
+++ cmdline.c	(working copy)
@@ -586,7 +586,7 @@
 	conf_set_bool(conf, CONF_nopty, true);   /* command => no terminal */
 	strbuf_free(command);
     }
-    if (!strcmp(p, "-P")) {
+    if ((!strcmp(p, "-P"))||(!strcmp(p, "-p"))) {
 	RETURN(2);
 	UNAVAILABLE_IN(TOOLTYPE_NONNETWORK);
 	SAVEABLE(1);		       /* lower priority than -ssh,-telnet */
Index: version.h
===================================================================
--- version.h	(revision 28629)
+++ version.h	(working copy)
@@ -1,6 +1,6 @@
 /* Generated by automated build script */
 #define RELEASE 0.72
 #define TEXTVER "Release 0.72"
-#define SSHVER "-Release-0.72"
+#define SSHVER "TortoisePlink-Release-0.72"
 #define BINARY_VERSION 0,72,0,0
 #define SOURCE_COMMIT "75cd6c8b2703137e574223d90d2f3ead9ca34acc"
Index: windows/wincons.c
===================================================================
--- windows/wincons.c	(revision 28540)
+++ windows/wincons.c	(working copy)
@@ -11,6 +11,8 @@
 #include "storage.h"
 #include "ssh.h"
 
+#include "LoginDialog.h"
+
 bool console_batch_mode = false;
 
 /*
@@ -28,40 +30,17 @@
     exit(code);
 }
 
-/*
- * Various error message and/or fatal exit functions.
- */
-void console_print_error_msg(const char *prefix, const char *msg)
-{
-    fputs(prefix, stderr);
-    fputs(": ", stderr);
-    fputs(msg, stderr);
-    fputc('\n', stderr);
-    fflush(stderr);
-}
-
-void console_print_error_msg_fmt_v(
-    const char *prefix, const char *fmt, va_list ap)
-{
-    char *msg = dupvprintf(fmt, ap);
-    console_print_error_msg(prefix, msg);
-    sfree(msg);
-}
-
-void console_print_error_msg_fmt(const char *prefix, const char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    console_print_error_msg_fmt_v(prefix, fmt, ap);
-    va_end(ap);
-}
-
 void modalfatalbox(const char *fmt, ...)
 {
     va_list ap;
+    char *stuff, morestuff[100];
     va_start(ap, fmt);
-    console_print_error_msg_fmt_v("FATAL ERROR", fmt, ap);
+    stuff = dupvprintf(fmt, ap);
     va_end(ap);
+    sprintf(morestuff, "%.70s Fatal Error", appname);
+    MessageBox(GetParentHwnd(), stuff, morestuff,
+        MB_SYSTEMMODAL | MB_ICONERROR | MB_OK);
+    sfree(stuff);
     cleanup_exit(1);
 }
 
@@ -68,14 +47,22 @@
 void nonfatal(const char *fmt, ...)
 {
     va_list ap;
+    char *stuff, morestuff[100];
     va_start(ap, fmt);
-    console_print_error_msg_fmt_v("ERROR", fmt, ap);
+    stuff = dupvprintf(fmt, ap);
     va_end(ap);
+    sprintf(morestuff, "%.70s Error", appname);
+    MessageBox(GetParentHwnd(), stuff, morestuff,
+        MB_SYSTEMMODAL | MB_ICONERROR | MB_OK);
+    sfree(stuff);
 }
 
 void console_connection_fatal(Seat *seat, const char *msg)
 {
-    console_print_error_msg("FATAL ERROR", msg);
+    char morestuff[100];
+    sprintf(morestuff, "%.70s Fatal Error", appname);
+    MessageBox(GetParentHwnd(), msg, morestuff,
+        MB_SYSTEMMODAL | MB_ICONERROR | MB_OK);
     cleanup_exit(1);
 }
 
@@ -89,8 +76,6 @@
     void (*callback)(void *ctx, int result), void *ctx)
 {
     int ret;
-    HANDLE hin;
-    DWORD savemode, i;
 
     static const char absentmsg_batch[] =
 	"The server's host key is not cached in the registry. You\n"
@@ -105,13 +90,12 @@
 	"think it is.\n"
 	"The server's %s key fingerprint is:\n"
 	"%s\n"
-	"If you trust this host, enter \"y\" to add the key to\n"
+	"If you trust this host, hit Yes to add the key to\n"
 	"PuTTY's cache and carry on connecting.\n"
 	"If you want to carry on connecting just once, without\n"
-	"adding the key to the cache, enter \"n\".\n"
-	"If you do not trust this host, press Return to abandon the\n"
-	"connection.\n"
-	"Store key in cache? (y/n) ";
+	"adding the key to the cache, hit No.\n"
+	"If you do not trust this host, hit Cancel to abandon the\n"
+	"connection.\n";
 
     static const char wrongmsg_batch[] =
 	"WARNING - POTENTIAL SECURITY BREACH!\n"
@@ -125,6 +109,7 @@
 	"Connection abandoned.\n";
     static const char wrongmsg[] =
 	"WARNING - POTENTIAL SECURITY BREACH!\n"
+	"\n"
 	"The server's host key does not match the one PuTTY has\n"
 	"cached in the registry. This means that either the\n"
 	"server administrator has changed the host key, or you\n"
@@ -133,17 +118,15 @@
 	"The new %s key fingerprint is:\n"
 	"%s\n"
 	"If you were expecting this change and trust the new key,\n"
-	"enter \"y\" to update PuTTY's cache and continue connecting.\n"
+	"hit Yes to update PuTTY's cache and continue connecting.\n"
 	"If you want to carry on connecting but without updating\n"
-	"the cache, enter \"n\".\n"
-	"If you want to abandon the connection completely, press\n"
-	"Return to cancel. Pressing Return is the ONLY guaranteed\n"
-	"safe choice.\n"
-	"Update cached key? (y/n, Return cancels connection) ";
+	"the cache, hit No.\n"
+	"If you want to abandon the connection completely, hit\n"
+	"Cancel. Hitting Cancel is the ONLY guaranteed safe\n" "choice.\n";
 
     static const char abandoned[] = "Connection abandoned.\n";
 
-    char line[32];
+	static const char mbtitle[] = "%s Security Alert";
 
     /*
      * Verify the key against the registry.
@@ -154,39 +137,49 @@
 	return 1;
 
     if (ret == 2) {		       /* key was different */
-	if (console_batch_mode) {
-	    fprintf(stderr, wrongmsg_batch, keytype, fingerprint);
-            return 0;
+	int mbret;
+	char *message, *title;
+
+	message = dupprintf(wrongmsg, keytype, fingerprint);
+	title = dupprintf(mbtitle, appname);
+
+	mbret = MessageBox(GetParentHwnd(), message, title, MB_ICONWARNING | MB_YESNOCANCEL | MB_DEFBUTTON3);
+	sfree(message);
+	sfree(title);
+	if (mbret == IDYES) {
+		store_host_key(host, port, keytype, keystr);
+		return 1;
 	}
-	fprintf(stderr, wrongmsg, keytype, fingerprint);
-	fflush(stderr);
-    }
+	else if (mbret == IDNO) 
+	{
+		return 1;
+	}
+	else
+		return 0;
+	}
+
     if (ret == 1) {		       /* key was absent */
-	if (console_batch_mode) {
-	    fprintf(stderr, absentmsg_batch, keytype, fingerprint);
-            return 0;
+	int mbret;
+	char *message, *title;
+	message = dupprintf(absentmsg, keytype, fingerprint);
+	title = dupprintf(mbtitle, appname);
+	mbret = MessageBox(GetParentHwnd(), message, title,
+		MB_ICONWARNING | MB_ICONWARNING | MB_YESNOCANCEL | MB_DEFBUTTON3);
+	sfree(message);
+	sfree(title);
+	if (mbret == IDYES)
+	{
+		store_host_key(host, port, keytype, keystr);
+		return 1;
 	}
-	fprintf(stderr, absentmsg, keytype, fingerprint);
-	fflush(stderr);
+	else if (mbret == IDNO)
+	{
+		return 1;
+	}
+	else
+		return 0;
     }
-
-    line[0] = '\0';         /* fail safe if ReadFile returns no data */
-
-    hin = GetStdHandle(STD_INPUT_HANDLE);
-    GetConsoleMode(hin, &savemode);
-    SetConsoleMode(hin, (savemode | ENABLE_ECHO_INPUT |
-			 ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT));
-    ReadFile(hin, line, sizeof(line) - 1, &i, NULL);
-    SetConsoleMode(hin, savemode);
-
-    if (line[0] != '\0' && line[0] != '\r' && line[0] != '\n') {
-	if (line[0] == 'y' || line[0] == 'Y')
-	    store_host_key(host, port, keytype, keystr);
-        return 1;
-    } else {
-	fprintf(stderr, abandoned);
-        return 0;
-    }
+	return 1;
 }
 
 int console_confirm_weak_crypto_primitive(
@@ -193,42 +186,26 @@
     Seat *seat, const char *algtype, const char *algname,
     void (*callback)(void *ctx, int result), void *ctx)
 {
-    HANDLE hin;
-    DWORD savemode, i;
-
     static const char msg[] =
 	"The first %s supported by the server is\n"
 	"%s, which is below the configured warning threshold.\n"
 	"Continue with connection? (y/n) ";
-    static const char msg_batch[] =
-	"The first %s supported by the server is\n"
-	"%s, which is below the configured warning threshold.\n"
-	"Connection abandoned.\n";
-    static const char abandoned[] = "Connection abandoned.\n";
 
-    char line[32];
+	static const char mbtitle[] = "%s Security Alert";
 
-    if (console_batch_mode) {
-	fprintf(stderr, msg_batch, algtype, algname);
-	return 0;
-    }
+	int mbret;
+	char *message, *title;
 
-    fprintf(stderr, msg, algtype, algname);
-    fflush(stderr);
+	message = dupprintf(msg, algtype, algname);
+	title = dupprintf(mbtitle, appname);
 
-    hin = GetStdHandle(STD_INPUT_HANDLE);
-    GetConsoleMode(hin, &savemode);
-    SetConsoleMode(hin, (savemode | ENABLE_ECHO_INPUT |
-			 ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT));
-    ReadFile(hin, line, sizeof(line) - 1, &i, NULL);
-    SetConsoleMode(hin, savemode);
-
-    if (line[0] == 'y' || line[0] == 'Y') {
-	return 1;
-    } else {
-	fprintf(stderr, abandoned);
-	return 0;
-    }
+	mbret = MessageBox(GetParentHwnd(), message, title, MB_ICONWARNING|MB_YESNO);
+	sfree(message);
+	sfree(title);
+	if (mbret == IDYES)
+		return 1;
+	else
+		return 0;
 }
 
 int console_confirm_weak_cached_hostkey(
@@ -256,25 +233,20 @@
 
     char line[32];
 
-    if (console_batch_mode) {
-	fprintf(stderr, msg_batch, algname, betteralgs);
-	return 0;
-    }
+    int mbret;
+    char *message, *title;
+    static const char mbtitle[] = "%s Security Alert";
 
-    fprintf(stderr, msg, algname, betteralgs);
-    fflush(stderr);
+    message = dupprintf(msg, algname, betteralgs);
+    title = dupprintf(mbtitle, appname);
 
-    hin = GetStdHandle(STD_INPUT_HANDLE);
-    GetConsoleMode(hin, &savemode);
-    SetConsoleMode(hin, (savemode | ENABLE_ECHO_INPUT |
-			 ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT));
-    ReadFile(hin, line, sizeof(line) - 1, &i, NULL);
-    SetConsoleMode(hin, savemode);
+    mbret = MessageBox(GetParentHwnd(), message, title, MB_ICONWARNING | MB_YESNOCANCEL | MB_DEFBUTTON3);
+    sfree(message);
+    sfree(title);
 
-    if (line[0] == 'y' || line[0] == 'Y') {
+    if (mbret == IDYES) {
 	return 1;
     } else {
-	fprintf(stderr, abandoned);
 	return 0;
     }
 }
@@ -332,25 +304,20 @@
 	"Logging will not be enabled.\n";
 
     char line[32];
+    int mbret;
+    char *message, *title;
+    static const char mbtitle[] = "%s Session log";
 
-    if (console_batch_mode) {
-	fprintf(stderr, msgtemplate_batch, FILENAME_MAX, filename->path);
-	fflush(stderr);
-	return 0;
-    }
-    fprintf(stderr, msgtemplate, FILENAME_MAX, filename->path);
-    fflush(stderr);
+    message = dupprintf(msgtemplate, FILENAME_MAX, filename->path);
+    title = dupprintf(mbtitle, appname);
 
-    hin = GetStdHandle(STD_INPUT_HANDLE);
-    GetConsoleMode(hin, &savemode);
-    SetConsoleMode(hin, (savemode | ENABLE_ECHO_INPUT |
-			 ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT));
-    ReadFile(hin, line, sizeof(line) - 1, &i, NULL);
-    SetConsoleMode(hin, savemode);
+    mbret = MessageBox(GetParentHwnd(), message, title, MB_ICONWARNING | MB_YESNOCANCEL | MB_DEFBUTTON3);
+    sfree(message);
+    sfree(title);
 
-    if (line[0] == 'y' || line[0] == 'Y')
+    if (mbret == IDYES)
 	return 2;
-    else if (line[0] == 'n' || line[0] == 'N')
+    else if (mbret == IDNO)
 	return 1;
     else
 	return 0;
@@ -430,7 +397,6 @@
 
 int console_get_userpass_input(prompts_t *p)
 {
-    HANDLE hin = INVALID_HANDLE_VALUE, hout = INVALID_HANDLE_VALUE;
     size_t curr_prompt;
 
     /*
@@ -442,97 +408,13 @@
             prompt_set_result(p->prompts[i], "");
     }
 
-    /*
-     * The prompts_t might contain a message to be displayed but no
-     * actual prompt. More usually, though, it will contain
-     * questions that the user needs to answer, in which case we
-     * need to ensure that we're able to get the answers.
-     */
-    if (p->n_prompts) {
-	if (console_batch_mode)
-	    return 0;
-	hin = GetStdHandle(STD_INPUT_HANDLE);
-	if (hin == INVALID_HANDLE_VALUE) {
-	    fprintf(stderr, "Cannot get standard input handle\n");
-	    cleanup_exit(1);
-	}
-    }
+    if (console_batch_mode)
+	return 0;
 
-    /*
-     * And if we have anything to print, we need standard output.
-     */
-    if ((p->name_reqd && p->name) || p->instruction || p->n_prompts) {
-	hout = GetStdHandle(STD_OUTPUT_HANDLE);
-	if (hout == INVALID_HANDLE_VALUE) {
-	    fprintf(stderr, "Cannot get standard output handle\n");
-	    cleanup_exit(1);
-	}
-    }
-
-    /*
-     * Preamble.
-     */
-    /* We only print the `name' caption if we have to... */
-    if (p->name_reqd && p->name) {
-	ptrlen plname = ptrlen_from_asciz(p->name);
-	console_write(hout, plname);
-        if (!ptrlen_endswith(plname, PTRLEN_LITERAL("\n"), NULL))
-	    console_write(hout, PTRLEN_LITERAL("\n"));
-    }
-    /* ...but we always print any `instruction'. */
-    if (p->instruction) {
-	ptrlen plinst = ptrlen_from_asciz(p->instruction);
-	console_write(hout, plinst);
-        if (!ptrlen_endswith(plinst, PTRLEN_LITERAL("\n"), NULL))
-	    console_write(hout, PTRLEN_LITERAL("\n"));
-    }
-
     for (curr_prompt = 0; curr_prompt < p->n_prompts; curr_prompt++) {
-
-	DWORD savemode, newmode;
-        size_t len;
 	prompt_t *pr = p->prompts[curr_prompt];
-
-	GetConsoleMode(hin, &savemode);
-	newmode = savemode | ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT;
-	if (!pr->echo)
-	    newmode &= ~ENABLE_ECHO_INPUT;
-	else
-	    newmode |= ENABLE_ECHO_INPUT;
-	SetConsoleMode(hin, newmode);
-
-	console_write(hout, ptrlen_from_asciz(pr->prompt));
-
-        len = 0;
-        while (1) {
-            DWORD ret = 0;
-
-            prompt_ensure_result_size(pr, len * 5 / 4 + 512);
-
-            if (!ReadFile(hin, pr->result + len, pr->resultsize - len - 1,
-                          &ret, NULL) || ret == 0) {
-                len = (size_t)-1;
-                break;
-            }
-            len += ret;
-            if (pr->result[len - 1] == '\n') {
-                len--;
-                if (pr->result[len - 1] == '\r')
-                    len--;
-                break;
-            }
-        }
-
-	SetConsoleMode(hin, savemode);
-
-	if (!pr->echo)
-            console_write(hout, PTRLEN_LITERAL("\r\n"));
-
-        if (len == (size_t)-1) {
-            return 0;                  /* failure due to read error */
-        }
-
-	pr->result[len] = '\0';
+	if (!DoLoginDialog(pr->result, pr->resultsize-1, pr->prompt))
+	return 0;
     }
 
     return 1; /* success */
Index: windows/winplink.c
===================================================================
--- windows/winplink.c	(revision 28540)
+++ windows/winplink.c	(working copy)
@@ -15,6 +15,10 @@
 
 #define WM_AGENT_CALLBACK (WM_APP + 4)
 
+#include <commctrl.h>
+#pragma comment(lib, "comctl32.lib")
+#pragma comment(linker, "\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
+
 struct agent_callback {
     void (*callback)(void *, void *, int);
     void *callback_ctx;
@@ -24,11 +28,15 @@
 
 void cmdline_error(const char *fmt, ...)
 {
-    va_list ap;
-    va_start(ap, fmt);
-    console_print_error_msg_fmt_v("plink", fmt, ap);
-    va_end(ap);
-    exit(1);
+	va_list ap;
+	char *stuff, morestuff[100];
+	va_start(ap, fmt);
+	stuff = dupvprintf(fmt, ap);
+	va_end(ap);
+	sprintf(morestuff, "%.70s Command Line Error", appname);
+	MessageBox(GetParentHwnd(), stuff, morestuff, MB_ICONERROR | MB_OK);
+	sfree(stuff);
+	exit(1);
 }
 
 HANDLE inhandle, outhandle, errhandle;
@@ -128,69 +136,74 @@
  */
 static void usage(void)
 {
-    printf("Plink: command-line connection utility\n");
-    printf("%s\n", ver);
-    printf("Usage: plink [options] [user@]host [command]\n");
-    printf("       (\"host\" can also be a PuTTY saved session name)\n");
-    printf("Options:\n");
-    printf("  -V        print version information and exit\n");
-    printf("  -pgpfp    print PGP key fingerprints and exit\n");
-    printf("  -v        show verbose messages\n");
-    printf("  -load sessname  Load settings from saved session\n");
-    printf("  -ssh -telnet -rlogin -raw -serial\n");
-    printf("            force use of a particular protocol\n");
-    printf("  -P port   connect to specified port\n");
-    printf("  -l user   connect with specified username\n");
-    printf("  -batch    disable all interactive prompts\n");
-    printf("  -proxycmd command\n");
-    printf("            use 'command' as local proxy\n");
-    printf("  -sercfg configuration-string (e.g. 19200,8,n,1,X)\n");
-    printf("            Specify the serial configuration (serial only)\n");
-    printf("The following options only apply to SSH connections:\n");
-    printf("  -pw passw login with specified password\n");
-    printf("  -D [listen-IP:]listen-port\n");
-    printf("            Dynamic SOCKS-based port forwarding\n");
-    printf("  -L [listen-IP:]listen-port:host:port\n");
-    printf("            Forward local port to remote address\n");
-    printf("  -R [listen-IP:]listen-port:host:port\n");
-    printf("            Forward remote port to local address\n");
-    printf("  -X -x     enable / disable X11 forwarding\n");
-    printf("  -A -a     enable / disable agent forwarding\n");
-    printf("  -t -T     enable / disable pty allocation\n");
-    printf("  -1 -2     force use of particular protocol version\n");
-    printf("  -4 -6     force use of IPv4 or IPv6\n");
-    printf("  -C        enable compression\n");
-    printf("  -i key    private key file for user authentication\n");
-    printf("  -noagent  disable use of Pageant\n");
-    printf("  -agent    enable use of Pageant\n");
-    printf("  -noshare  disable use of connection sharing\n");
-    printf("  -share    enable use of connection sharing\n");
-    printf("  -hostkey aa:bb:cc:...\n");
-    printf("            manually specify a host key (may be repeated)\n");
-    printf("  -sanitise-stderr, -sanitise-stdout, "
-           "-no-sanitise-stderr, -no-sanitise-stdout\n");
-    printf("            do/don't strip control chars from standard "
-           "output/error\n");
-    printf("  -no-antispoof   omit anti-spoofing prompt after "
-           "authentication\n");
-    printf("  -m file   read remote command(s) from file\n");
-    printf("  -s        remote command is an SSH subsystem (SSH-2 only)\n");
-    printf("  -N        don't start a shell/command (SSH-2 only)\n");
-    printf("  -nc host:port\n");
-    printf("            open tunnel in place of session (SSH-2 only)\n");
-    printf("  -sshlog file\n");
-    printf("  -sshrawlog file\n");
-    printf("            log protocol details to a file\n");
-    printf("  -shareexists\n");
-    printf("            test whether a connection-sharing upstream exists\n");
+    char buf[10000];
+    int j = 0;
+    j += sprintf(buf+j, "TortoisePlink: command-line connection utility (based on PuTTY Plink)\n");
+    j += sprintf(buf+j, "%s\n", ver);
+    j += sprintf(buf+j, "Usage: tortoiseplink [options] [user@]host [command]\n");
+    j += sprintf(buf+j, "       (\"host\" can also be a PuTTY saved session name)\n");
+    j += sprintf(buf+j, "Options:\n");
+    j += sprintf(buf+j, "  -V        print version information and exit\n");
+    j += sprintf(buf+j, "  -pgpfp    print PGP key fingerprints and exit\n");
+    j += sprintf(buf+j, "  -v        show verbose messages\n");
+    j += sprintf(buf+j, "  -load sessname  Load settings from saved session\n");
+    j += sprintf(buf+j, "  -ssh -telnet -rlogin -raw -serial\n");
+    j += sprintf(buf+j, "            force use of a particular protocol\n");
+    j += sprintf(buf+j, "  -P port   connect to specified port\n");
+    j += sprintf(buf+j, "  -l user   connect with specified username\n");
+    j += sprintf(buf+j, "  -batch    disable all interactive prompts\n");
+    j += sprintf(buf+j, "  -proxycmd command\n");
+    j += sprintf(buf+j, "            use 'command' as local proxy\n");
+    j += sprintf(buf+j, "  -sercfg configuration-string (e.g. 19200,8,n,1,X)\n");
+    j += sprintf(buf+j, "            Specify the serial configuration (serial only)\n");
+    j += sprintf(buf+j, "The following options only apply to SSH connections:\n");
+    j += sprintf(buf+j, "  -pw passw login with specified password\n");
+    j += sprintf(buf+j, "  -D [listen-IP:]listen-port\n");
+    j += sprintf(buf+j, "            Dynamic SOCKS-based port forwarding\n");
+    j += sprintf(buf+j, "  -L [listen-IP:]listen-port:host:port\n");
+    j += sprintf(buf+j, "            Forward local port to remote address\n");
+    j += sprintf(buf+j, "  -R [listen-IP:]listen-port:host:port\n");
+    j += sprintf(buf+j, "            Forward remote port to local address\n");
+    j += sprintf(buf+j, "  -X -x     enable / disable X11 forwarding\n");
+    j += sprintf(buf+j, "  -A -a     enable / disable agent forwarding\n");
+    j += sprintf(buf+j, "  -t -T     enable / disable pty allocation\n");
+    j += sprintf(buf+j, "  -1 -2     force use of particular protocol version\n");
+    j += sprintf(buf+j, "  -4 -6     force use of IPv4 or IPv6\n");
+    j += sprintf(buf+j, "  -C        enable compression\n");
+    j += sprintf(buf+j, "  -i key    private key file for user authentication\n");
+    j += sprintf(buf+j, "  -noagent  disable use of Pageant\n");
+    j += sprintf(buf+j, "  -agent    enable use of Pageant\n");
+    j += sprintf(buf+j, "  -noshare  disable use of connection sharing\n");
+    j += sprintf(buf+j, "  -share    enable use of connection sharing\n");
+    j += sprintf(buf+j, "  -hostkey aa:bb:cc:...\n");
+    j += sprintf(buf+j, "            manually specify a host key (may be repeated)\n");
+    j += sprintf(buf+j, "  -sanitise-stderr, -sanitise-stdout,\n");
+    j += sprintf(buf+j, "  -no-sanitise-stderr, -no-sanitise-stdout\n");
+    j += sprintf(buf+j, "            do/don't strip control chars from standard\n");
+    j += sprintf(buf+j, "            output/error\n");
+    j += sprintf(buf+j, "  -no-antispoof   omit anti-spoofing prompt after\n");
+    j += sprintf(buf+j, "            authentication\n");
+    j += sprintf(buf+j, "  -m file   read remote command(s) from file\n");
+    j += sprintf(buf+j, "  -s        remote command is an SSH subsystem (SSH-2 only)\n");
+    j += sprintf(buf+j, "  -N        don't start a shell/command (SSH-2 only)\n");
+    j += sprintf(buf+j, "  -nc host:port\n");
+    j += sprintf(buf+j, "            open tunnel in place of session (SSH-2 only)\n");
+    j += sprintf(buf+j, "  -sshlog file\n");
+    j += sprintf(buf+j, "  -sshrawlog file\n");
+    j += sprintf(buf+j, "            log protocol details to a file\n");
+    j += sprintf(buf+j, "  -shareexists\n");
+    j += sprintf(buf+j, "            test whether a connection-sharing upstream exists\n");
+    MessageBox(NULL, buf, "TortoisePlink", MB_ICONINFORMATION);
     exit(1);
 }
 
 static void version(void)
 {
+    char buf[1000];
     char *buildinfo_text = buildinfo("\n");
-    printf("plink: %s\n%s\n", ver, buildinfo_text);
+    sprintf(buf, "TortoisePlink: %s\n%s\n", ver, buildinfo_text);
     sfree(buildinfo_text);
+    MessageBox(NULL, buf, "TortoisePlink", MB_ICONINFORMATION);
     exit(0);
 }
 
@@ -277,6 +290,7 @@
 
     dll_hijacking_protection();
 
+    InitCommonControls();
     sklist = NULL;
     skcount = sksize = 0;
     /*
@@ -299,24 +313,11 @@
     conf = conf_new();
     do_defaults(NULL, conf);
     loaded_session = false;
-    default_protocol = conf_get_int(conf, CONF_protocol);
-    default_port = conf_get_int(conf, CONF_port);
     errors = false;
-    {
-	/*
-	 * Override the default protocol if PLINK_PROTOCOL is set.
-	 */
-	char *p = getenv("PLINK_PROTOCOL");
-	if (p) {
-            const struct BackendVtable *vt = backend_vt_from_name(p);
-            if (vt) {
-                default_protocol = vt->protocol;
-                default_port = vt->default_port;
-		conf_set_int(conf, CONF_protocol, default_protocol);
-		conf_set_int(conf, CONF_port, default_port);
-	    }
-	}
-    }
+    conf_set_int(conf, CONF_protocol, default_protocol);
+    conf_set_int(conf, CONF_port, default_port);
+    conf_set_bool(conf, CONF_agentfwd, FALSE);
+    conf_set_bool(conf, CONF_x11_forward, FALSE);
     while (--argc) {
 	char *p = *++argv;
         int ret = cmdline_process_param(p, (argc > 1 ? argv[1] : NULL),
@@ -323,7 +324,7 @@
                                         1, conf);
         if (ret == -2) {
             fprintf(stderr,
-                    "plink: option \"%s\" requires an argument\n", p);
+                    "TortoisePlink: option \"%s\" requires an argument\n", p);
             errors = true;
         } else if (ret == 2) {
             --argc, ++argv;
@@ -330,7 +331,7 @@
         } else if (ret == 1) {
             continue;
         } else if (!strcmp(p, "-batch")) {
-            console_batch_mode = true;
+            // ignore and do not print an error message
         } else if (!strcmp(p, "-s")) {
             /* Save status to write to conf later. */
             use_subsystem = true;
@@ -375,7 +376,7 @@
             strbuf_free(cmdbuf);
             break;		       /* done with cmdline */
         } else {
-            fprintf(stderr, "plink: unknown option \"%s\"\n", p);
+            fprintf(stderr, "TortoisePlink: unknown option \"%s\"\n", p);
             errors = true;
         }
     }
@@ -418,7 +419,7 @@
 
     sk_init();
     if (p_WSAEventSelect == NULL) {
-	fprintf(stderr, "Plink requires WinSock 2\n");
+	fprintf(stderr, "TortoisePlink requires WinSock 2\n");
 	return 1;
     }
 
